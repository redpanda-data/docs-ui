<script>
/**
 * List of result types we allow to open inside the in-panel preview.
 * Keeping this explicit prevents surprising navigation for types we don't
 * fully support.
 */
const SUPPORTED_PREVIEW_TYPES = ['doc', 'api', 'api endpoint', 'api group'];

/**
 * ---- Build-time context (Handlebars) ----
 * These strings are resolved at build time. They power “contextual filters”
 * so initial search state reflects the page the user is on.
 */
const INITIAL_TAG = `
{{#if (eq page.component.name 'api')}}
{{{site.components.ROOT.title}}} v{{{site.components.ROOT.latest.version}}}
{{else if (and (is-prerelease page) page.displayVersion)}}
{{{page.component.title}}} v{{{page.displayVersion}}}
{{else if page.componentVersion.version}}
{{{page.component.title}}} v{{{page.componentVersion.version}}}
{{else}}
{{{page.component.title}}}
{{/if}}`.trim();

const LATEST_ENTERPRISE = `{{{site.components.ROOT.title}}} v{{{site.components.ROOT.latest.version}}}`.trim();

const PRERELEASE = `
{{#if (and (is-prerelease page) page.displayVersion)}}
true
{{else}}
false
{{/if}}`.trim();

/**
 * NOTE: We key off component *title* here (not "name"); this mirrors the site’s
 * taxonomy. If you ever change the source,
 * update the “Cloud” check accordingly.
 */
const COMPONENT_NAME = `{{{page.component.title}}}`.trim();

/**
 * The “catalog” of product/API tags we want available by default.
 * For Cloud, we intentionally exclude "Admin API" from defaults.
 */
const INITIAL_TAGS =
  COMPONENT_NAME === 'Cloud'
    ? ['Labs', 'Schema Registry API', 'HTTP Proxy API', 'Cloud Control Plane API', 'Cloud Data Plane API']
    : ['Labs', 'Connect', 'Admin API', 'Schema Registry API', 'HTTP Proxy API', 'Cloud Control Plane API', 'Cloud Data Plane API'];

/** Version added to the “View all” link to scope whole-site search. */
const VERSION = PRERELEASE === 'true'
  ? `{{{page.displayVersion}}}`.trim()
  : `{{{page.componentVersion.version}}}`.trim();

/**
 * Merge a contextual tag (from the current page) with our initial tags, dedupe,
 * and shape them to the Tags plugin’s expected structure: { label, facet }.
 * Tags plugin: https://www.algolia.com/doc/ui-libraries/autocomplete/api-reference/plugins/tags-plugin/
 */
const applyFilterTags = (initialTags, initialTag) => {
  if (!initialTag) return initialTags.map((tag) => ({ label: tag, facet: '_tags' }));
  let mergedTags;
  // Home/Labs broaden context so first query is helpful for new users.
  if (initialTag === 'Home' || initialTag === 'Labs') {
    mergedTags = [...initialTags, 'Cloud', LATEST_ENTERPRISE];
  } else {
    mergedTags = [...initialTags, initialTag];
  }
  mergedTags = [...new Set(mergedTags)];
  return mergedTags.map((tag) => ({ label: tag, facet: '_tags' }));
};

/**
 * Convert selected tag facets into Algolia `tagFilters`.
 * `tagFilters` ORs within an array; multiple arrays would AND.
 * Docs: https://www.algolia.com/doc/api-reference/api-parameters/tagFilters/
 */
function mapToAlgoliaFilters(tagsByFacet) {
  const labels = (tagsByFacet._tags || []).map(t => t.label);
  return labels.length ? [labels] : undefined;
}

/** Small utilities */
function groupBy(items, predicate) {
  return items.reduce((acc, item) => {
    const key = predicate(item);
    if (!Object.prototype.hasOwnProperty.call(acc, key)) {
      acc[key] = [];
    }
    acc[key].push(item);
    return acc;
  }, {});
}

/** Normalize to compare labels case/space-insensitively. */
const normalizeLabel = (s) => (s || '').trim().replace(/\s+/g, ' ').toLowerCase();

/**
 * Global toggle used by checkbox UI in our custom facet dropdown.
 * We expose this on `window` so event handlers defined in template strings
 * (which may be re-created on each render) always call a stable function.
 * See the “Why we attach to window” section below.
 */
let __algoliaTagsPlugin = null;
window.__algoliaToggleFilter = function(label, checked) {
  if (!label || !__algoliaTagsPlugin) return;
  const prev = __algoliaTagsPlugin.data.tags || [];
  const isSame = (t) => normalizeLabel(t.label) === normalizeLabel(label);
  const exists = prev.some(isSame);
  if (checked && !exists) {
    __algoliaTagsPlugin.data.setTags([...prev, { label, facet: '_tags' }]);
  } else if (!checked && exists) {
    __algoliaTagsPlugin.data.setTags(prev.filter(t => !isSame(t)));
  }
};

/** Stable refs + listeners for outside-click / Esc handling on the dropdown. */
const __dropdownRefs = { menu: null, toggle: null };
let __dropdownOutsideHandler = null;
let __dropdownKeydownHandler = null;

window.addEventListener('DOMContentLoaded', function () {
  /**
   * We load Algolia Autocomplete UMD bundles via <script>, so they live on `window`.
   * - Autocomplete core: https://www.algolia.com/doc/ui-libraries/autocomplete/api-reference/autocomplete/
   * - getAlgoliaResults / getAlgoliaFacets:
   *   https://www.algolia.com/doc/ui-libraries/autocomplete/api-reference/sources/#param-getalgoliaresults
   *   https://www.algolia.com/doc/ui-libraries/autocomplete/api-reference/sources/#param-getalgoliafacets
   * - Recent searches plugin:
   *   https://www.algolia.com/doc/ui-libraries/autocomplete/api-reference/plugins/recent-searches-plugin/
   * - Tags plugin:
   *   https://www.algolia.com/doc/ui-libraries/autocomplete/api-reference/plugins/tags-plugin/
   */
  const { createTagsPlugin } = window['@algolia/autocomplete-plugin-tags'];
  const { autocomplete, getAlgoliaResults, getAlgoliaFacets } = window['@algolia/autocomplete-js'];
  const { createLocalStorageRecentSearchesPlugin } = window['@algolia/autocomplete-plugin-recent-searches'];

  /**
   * ---- Search Insights (analytics) ----
   * Algolia recommends a global queue `aa` while the script loads,
   * then `aa('init', {...})` to connect events. This ensures click/conversion
   * events are attributed to queries via queryID.
   * Insights JS: https://www.algolia.com/doc/api-client/insights/js/
   * Autocomplete + Insights: https://www.algolia.com/doc/ui-libraries/autocomplete/guides/insights/
   */
  window.aa = window.aa || function(){ (window.aa.q = window.aa.q || []).push(arguments); };
  if (!window.__aaLoaderInserted) {
    const si = document.createElement('script');
    si.async = 1;
    si.src = 'https://cdn.jsdelivr.net/npm/search-insights@2';
    document.head.appendChild(si);
    window.__aaLoaderInserted = true; // guard against double-insert
  }
  aa('init', {
    appId: '{{{env.ALGOLIA_APP_ID}}}',
    apiKey: '{{{env.ALGOLIA_API_KEY}}}',
    useCookie: true, // helps stitch sessions for analytics
  });

  /**
   * Algolia JS client instance used by Autocomplete helpers.
   * Client install/start: https://www.algolia.com/doc/api-client/getting-started/install/javascript/
   */
  const searchClient = algoliasearch(
    '{{{env.ALGOLIA_APP_ID}}}',
    '{{{env.ALGOLIA_API_KEY}}}'
  );

  /** Keep 5 recent searches in localStorage for quick recall. */
  const recentSearchesPlugin = createLocalStorageRecentSearchesPlugin({
    key: 'RECENT_SEARCH',
    limit: 5,
  });

  /**
   * Tags plugin manages selected tags inside Autocomplete state/context.
   * We subscribe this plugin to the “filters” source so clicking a facet item
   * turns directly into a tag.
   */
  const tagsPlugin = createTagsPlugin({
    getTagsSubscribers() {
      return [
        {
          sourceId: 'filters',
          getTag({ item }) {
            return item; // item has shape { label, facet }
          },
        },
      ];
    },
    initialTags: applyFilterTags(INITIAL_TAGS, INITIAL_TAG),
  });
  __algoliaTagsPlugin = tagsPlugin; // used by our window.__algoliaToggleFilter

  /**
   * ---- Autocomplete instance ----
   * - detachedMediaQuery: '' -> detached mode opens a modal
   *   https://www.algolia.com/doc/ui-libraries/autocomplete/api-reference/autocomplete/#param-detachedmediaquery
   * - insights: true -> Autocomplete sends events to `aa`
   *   https://www.algolia.com/doc/ui-libraries/autocomplete/guides/insights/#enabling-insights
   * - defaultActiveItemId: 0 -> keyboard UX selects first result by default
   */
  const autocompleteInstance = autocomplete({
    container: '#autocomplete',
    placeholder: 'Search',
    detachedMediaQuery: '',
    plugins: [recentSearchesPlugin, tagsPlugin],
    insights: true,
    defaultActiveItemId: 0,

    /**
     * Keep derived UI (preview, dropdown listeners, facet cache) in sync with
     * Autocomplete state in a single place.
     * onStateChange docs:
     * https://www.algolia.com/doc/ui-libraries/autocomplete/api-reference/autocomplete/#param-onstatechange
     */
    onStateChange({ state, prevState, setContext }) {
      const prevQ = prevState?.query ?? '';
      const nextQ = state.query ?? '';

      // 1) Detect tag changes (order-insensitive) so we update preview accordingly.
      const tagKey = (s) => (s?.context?.tagsPlugin?.tags || [])
        .map((t) => `${t.facet}:${t.label}`)
        .sort()
        .join('|');
      const prevTagKey = tagKey(prevState);
      const nextTagKey = tagKey(state);
      const tagsChanged = prevTagKey !== nextTagKey;

      // 2) First result of the "docs" source drives the preview pane.
      const docsCollection = state.collections.find((c) => c.source.sourceId === 'docs');
      const firstHit = docsCollection?.items?.[0] || null;

      // 3) Persist the facet list in context to avoid flicker during async refresh.
      //    Context docs: https://www.algolia.com/doc/ui-libraries/autocomplete/core-concepts/context/
      const prevFilters = prevState?.context?.filtersSourceItems || [];
      const filtersSource = state.collections.find(c => c.source.sourceId === 'filters');
      const currFilters = (filtersSource && Array.isArray(filtersSource.items))
        ? filtersSource.items
        : prevFilters;

      const same = prevFilters.length === currFilters.length &&
                   prevFilters.every((p, i) => p?.label === currFilters[i]?.label);

      if (!same || tagsChanged) {
        setContext({ ...state.context, filtersSourceItems: currFilters });
      }

      // 4) Attach/detach global listeners only while the dropdown is open.
      const wasOpen = !!(prevState?.context?.dropdownOpen);
      const isOpen  = !!(state?.context?.dropdownOpen);
      if (isOpen && !wasOpen) {
        const close = () => setContext({ ...state.context, dropdownOpen: false });
        __dropdownOutsideHandler = (e) => {
          const menu = __dropdownRefs.menu;
          const toggle = __dropdownRefs.toggle;
          if (!menu) return;
          if (menu.contains(e.target) || (toggle && toggle.contains(e.target))) return;
          close();
        };
        __dropdownKeydownHandler = (e) => {
          if (e.key === 'Escape') close();
        };
        document.addEventListener('pointerdown', __dropdownOutsideHandler, true);
        document.addEventListener('keydown', __dropdownKeydownHandler);
      } else if (!isOpen && wasOpen) {
        if (__dropdownOutsideHandler) {
          document.removeEventListener('pointerdown', __dropdownOutsideHandler, true);
          __dropdownOutsideHandler = null;
        }
        if (__dropdownKeydownHandler) {
          document.removeEventListener('keydown', __dropdownKeydownHandler);
          __dropdownKeydownHandler = null;
        }
      }

      // 5) Update or seed preview when query/tags change or first load.
      if ((nextQ && nextQ !== prevQ) || tagsChanged) {
        setContext({ ...state.context, preview: firstHit });
        return;
      }
      if (!state.context.preview && firstHit) {
        setContext({ ...state.context, preview: firstHit });
      }
    },

    /**
     * Custom render for header (filters & AI), results, preview, and footer.
     * Templates/helpers:
     * https://www.algolia.com/doc/ui-libraries/autocomplete/core-concepts/templates/
     */
    render({ children, state, render, html, components }, root) {
      const { preview } = state.context;
      const currentQuery = state.query;

      /** ---- Facet dropdown model ----
       * We union three sources to produce a stable checkbox list:
       *  - server facets (fresh from index),
       *  - our known catalog (INITIAL_TAGS),
       *  - user-selected tags (to keep checked state if server facet drops).
       */
      const serverFacetItems = (state.context.filtersSourceItems || []);
      const selectedTagObjs = (state.context?.tagsPlugin?.tags || []).filter(t => t.facet === '_tags');
      const selectedSet = new Set(selectedTagObjs.map(t => normalizeLabel(t.label)));

      const serverLabels = serverFacetItems.map(i => i.label);
      const knownLabels  = applyFilterTags(INITIAL_TAGS, INITIAL_TAG).map(t => t.label);
      const selectedLabels = selectedTagObjs.map(t => t.label);

      const unionMap = new Map();
      [...serverLabels, ...knownLabels, ...selectedLabels].forEach(l => {
        const norm = normalizeLabel(l);
        if (!unionMap.has(norm)) unionMap.set(norm, l);
      });

      const checkboxItems = Array.from(unionMap.values())
        .map(label => ({ label, checked: selectedSet.has(normalizeLabel(label)) }))
        .sort((a, b) => (Number(b.checked) - Number(a.checked)) || a.label.localeCompare(b.label));

      const selectedCount = selectedTagObjs.length;
      const buttonText = selectedCount ? `Filter results (${selectedCount})` : 'Filter results';
      const ariaLabel  = selectedCount
        ? `Change included filters. ${selectedCount} selected.`
        : 'Choose filters to include results';

      const dropdownOpen = !!state.context.dropdownOpen;

      // Keyboard nav inside the custom menu (↑/↓/Enter/Space)
      const handleDropdownKeyDown = (e) => {
        const items = Array.from(__dropdownRefs.menu?.querySelectorAll('.context-dropdown-item') || []);
        const current = document.activeElement;
        let idx = items.indexOf(current);
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          items[(idx + 1) % items.length]?.focus();
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          items[(idx - 1 + items.length) % items.length]?.focus();
        } else if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          const cb = current?.querySelector('input[type="checkbox"]');
          if (cb) {
            cb.checked = !cb.checked;
            window.__algoliaToggleFilter(current.dataset.label, cb.checked);
          }
        }
      };

      // Toggle dropdown through Autocomplete context (so onStateChange runs).
      const setDropdownOpen = (open) => {
        window.__algoliaAutocompleteInstance.setContext({ ...state.context, dropdownOpen: open });
      };

      // The dropdown UI itself (button + menu)
      const dropdown = html`
        <div class="context-dropdown algolia-filters-dropdown" style="display:inline-block;position:relative;z-index:10000;">
          <button
            type="button"
            class="context-dropdown-toggle"
            aria-label=${ariaLabel}
            aria-haspopup="menu"
            aria-expanded="${dropdownOpen}"
            aria-controls="algolia-filters-dropdown-menu"
            ref=${el => (__dropdownRefs.toggle = el)}
            onPointerDown=${e => { e.preventDefault(); e.stopPropagation(); setDropdownOpen(!dropdownOpen); }}
            onClick=${e => e.stopPropagation()}
            onKeyDown=${e => { if (e.key === 'ArrowDown' || e.key === 'Enter' || e.key === ' ') { e.preventDefault(); setDropdownOpen(true); setTimeout(() => { __dropdownRefs.menu?.querySelector('.context-dropdown-item')?.focus(); }, 0); } }}
          >
            <span>${buttonText}</span>
            <span class="context-dropdown-arrow" aria-hidden="true" style="display:inline-block;transition:transform 0.2s ease;${dropdownOpen ? 'transform:rotate(180deg);' : ''}">
              <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 6l4 4 4-4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
            </span>
          </button>

          <ul
            id="algolia-filters-dropdown-menu"
            class="context-dropdown-menu"
            role="menu"
            tabIndex="-1"
            ref=${el => (__dropdownRefs.menu = el)}
            style="min-width:220px;max-height:320px;overflow:auto;display:${dropdownOpen ? 'block' : 'none'};padding:6px 0;"
            onKeyDown=${handleDropdownKeyDown}
          >
            ${
              checkboxItems.length === 0
                ? html`<li class="context-dropdown-item" role="menuitem" tabIndex="0" aria-disabled="true" style="padding:6px 12px;">No facets</li>`
                : checkboxItems.map(item => html`
                  <li
                    class="context-dropdown-item"
                    role="menuitemcheckbox"
                    aria-checked="${item.checked ? 'true' : 'false'}"
                    data-label="${item.label}"
                    tabIndex="0"
                    style="padding:4px 12px;"
                  >
                    <label style="display:flex;gap:8px;align-items:center;cursor:pointer;">
                      <input
                        type="checkbox"
                        checked=${item.checked}
                        onChange=${e => { window.__algoliaToggleFilter(item.label, e.target.checked); }}
                        onPointerDown=${e => e.stopPropagation()}
                      />
                      <span>${item.label}</span>
                    </label>
                  </li>
                `)
            }
            ${
              checkboxItems.length
                ? html`<li style="display:flex;justify-content:space-between;gap:8px;padding:8px 12px;border-top:1px solid rgba(0,0,0,0.08);margin-top:6px;">
                    <button style="color:var(--body-font-color);" type="button"
                      onPointerDown=${e => { e.preventDefault(); e.stopPropagation(); selectedTagObjs.length && __algoliaTagsPlugin.data.setTags([]); }}
                    >Clear all</button>
                    <button style="color:var(--body-font-color);" type="button"
                      onPointerDown=${e => { e.preventDefault(); e.stopPropagation(); setDropdownOpen(false); }}
                    >Close</button>
                  </li>`
                : ''
            }
          </ul>
        </div>
      `;

      /**
       * For API endpoint results we show a tiny example to reduce clicks.
       * This is pure UI enrichment: not required by Algolia.
       */
      const hasEndpoint = !!(preview && (preview.method || preview.path));
      let endpointLine = '';
      let curlExample = '';
      if (hasEndpoint) {
        const method = (preview.method || 'GET').toUpperCase();
        const path = preview.path || '';
        endpointLine = `${method} ${path}`;
        let origin = '';
        try { origin = new URL(preview.url || '').origin; } catch (e) { /* no-op */ }
        curlExample = `curl -X ${method} '${origin ? origin + path : path}'`;
      }

      // Optional: Integrate your AI assistant with the current query.
      const askAIButton = currentQuery
        ? html`<button
            type="button"
            class="ask-ai"
            onClick=${() => {
              if (window.Kapa?.open) {
                window.Kapa.open({ query: currentQuery });
                autocompleteInstance.setIsOpen(false);
              }
            }}
          >
            <!-- icon omitted -->
            Ask AI about "${currentQuery}"
          </button>`
        : '';

      // Compose a “View all results” link that respects product + version context.
      const componentTitle = '{{{page.component.title}}}';
      const productParams = (() => {
        if (componentTitle === 'Cloud') return '&product[0]=Cloud&product[1]=Connect';
        if (componentTitle === 'Self-Managed') return '&product[0]=Self-Managed&product[1]=Connect';
        return '';
      })();
      const viewAllLink = currentQuery
        ? html`<a
            class="view-all"
            href="{{{relativize '/search' }}}?q=${encodeURIComponent(currentQuery)}${VERSION ? `&version=${VERSION}` : ''}${productParams}"
          >
            View all results
          </a>`
        : '';

      // Layout: header (filters/AI), results list, right-side preview, footer tips.
      render(
        html`<div class="aa-Header">
          ${dropdown}
          ${askAIButton}
        </div>
        <div class="aa-Grid">
          <div class="aa-Results aa-Column--scrollable">${children}</div>
          ${
            preview
              ? html`<div class="aa-Preview aa-Column doc">
                  <div class="aa-PanelLayout aa-Panel--scrollable">
                    ${
                      preview.breadcrumbs
                        ? html`<div class="breadcrumbs">
                            <ul>
                              ${preview.breadcrumbs.map(
                                (breadcrumb) =>
                                  html`<li>
                                    <a
                                      onClick=${(event) => {
                                        event.stopPropagation();
                                        // Click analytics requires clickAnalytics: true and a queryID.
                                        // Docs: https://www.algolia.com/doc/api-reference/api-parameters/clickAnalytics/
                                        aa('clickedObjectIDsAfterSearch', {
                                          eventName: 'Preview Selected',
                                          index: state.context.preview.__autocomplete_indexName,
                                          queryID: state.context.preview.__autocomplete_queryID,
                                          objectIDs: [state.context.preview.objectID],
                                          positions: [state.activeItemId + 1], // positions start at 1
                                        });
                                      }}
                                      href="${breadcrumb.u}"
                                    >
                                      ${breadcrumb.t}
                                    </a>
                                  </li>`
                              )}
                            </ul>
                          </div>`
                        : ''
                    }
                    <h3>${components.Highlight({ hit: preview, attribute: 'title' })}</h3>
                    <p>${
                      preview.intro
                        ? components.Highlight({ hit: preview, attribute: 'intro' })
                        : preview.description
                        ? components.Highlight({ hit: preview, attribute: 'description' })
                        : ''
                    }</p>
                    ${ preview.api ? html`<div class="aa-ItemContentRow"><div class="aa-ItemContentTitle result-type">${preview.api}</div></div>` : '' }
                    ${ hasEndpoint ? html`<div class="endpoint-example">
                        <h4>Endpoint</h4>
                        <pre><code>${endpointLine}</code></pre>
                        <h4>Example</h4>
                        <pre><code>${curlExample}</code></pre>
                      </div>` : '' }
                    ${
                      preview.image
                        ? html`<div class="aa-ItemIcon">
                            ${
                              SUPPORTED_PREVIEW_TYPES.includes((preview.type || '').toLowerCase())
                                ? html`<a
                                    onClick=${(event) => {
                                      event.stopPropagation();
                                      aa('clickedObjectIDsAfterSearch', {
                                        eventName: 'Preview Selected',
                                        index: state.context.preview.__autocomplete_indexName,
                                        queryID: state.context.preview.__autocomplete_queryID,
                                        objectIDs: [state.context.preview.objectID],
                                        positions: [state.activeItemId + 1],
                                      });
                                    }}
                                    href="${preview.url || preview.objectID}"
                                  >
                                    <img src="${preview.image}" alt="${preview.title || ''}" />
                                  </a>`
                                : html`<a
                                    onClick=${(event) => {
                                      event.stopPropagation();
                                      aa('clickedObjectIDsAfterSearch', {
                                        eventName: 'Preview Selected',
                                        index: state.context.preview.__autocomplete_indexName,
                                        queryID: state.context.preview.__autocomplete_queryID,
                                        objectIDs: [state.context.preview.objectID],
                                        positions: [state.activeItemId + 1],
                                      });
                                    }}
                                    target="_blank" rel="noopener noreferrer"
                                    href="${preview.url || preview.objectID}"
                                  >
                                    <img src="${preview.image}" alt="${preview.title || ''}" />
                                  </a>`
                            }
                          </div>`
                        : ''
                    }
                    <div class="toc sidebar">
                      <div class="toc-menu">
                        ${preview.titles && preview.titles.length > 0 ? html`<h4>On this page</h4>` : ''}
                        <ul>
                          ${(preview.titles || []).slice(0, 15).map(
                            (title) => html`<li>
                              ${
                                SUPPORTED_PREVIEW_TYPES.includes((state.context.preview.type || '').toLowerCase())
                                  ? html`<a
                                        onClick=${(event) => {
                                          event.stopPropagation();
                                          aa('clickedObjectIDsAfterSearch', {
                                            eventName: 'Preview Selected',
                                            index: state.context.preview.__autocomplete_indexName,
                                            queryID: state.context.preview.__autocomplete_queryID,
                                            objectIDs: [state.context.preview.objectID],
                                            positions: [state.activeItemId + 1],
                                          });
                                        }}
                                        href="${(preview.url || preview.objectID)}#${title.h}"
                                      >
                                        ${components.Highlight({ hit: title, attribute: 't' })}
                                      </a>`
                                  : html`<a
                                        onClick=${(event) => {
                                          event.stopPropagation();
                                          aa('clickedObjectIDsAfterSearch', {
                                            eventName: 'Preview Selected',
                                            index: state.context.preview.__autocomplete_indexName,
                                            queryID: state.context.preview.__autocomplete_queryID,
                                            objectIDs: [state.context.preview.objectID],
                                            positions: [state.activeItemId + 1],
                                          });
                                        }}
                                        target="_blank" rel="noopener noreferrer"
                                        href="${(preview.url || preview.objectID)}#${title.h}"
                                      >
                                        ${components.Highlight({ hit: title, attribute: 't' })}
                                      </a>`
                              }
                            </li>`
                          )}
                        </ul>
                      </div>
                    </div>
                  </div>
                </div>
                <footer class="search-footer">
                  <ul class="search-commands">
                    <li><kbd class="algolia-command" aria-label="Enter to select">⏎</kbd><span class="algolia-label">to select</span></li>
                    <li><kbd class="algolia-command">↓</kbd><kbd class="algolia-command">↑</kbd><span class="algolia-label">to navigate</span></li>
                    <li><kbd class="algolia-command">Esc</kbd><span class="algolia-label">to close</span></li>
                  </ul>
                  ${viewAllLink}
                </footer>`
              : ''
          }
        </div>`,
        root
      );
    },

    /**
     * Define our data sources:
     *  - "filters": facet values for the _tags facet (used by the tags plugin)
     *  - "docs":    actual content/hits
     * Sources overview: https://www.algolia.com/doc/ui-libraries/autocomplete/core-concepts/sources/
     */
    getSources({ query, state }) {
      const tagsByFacet = groupBy(state.context.tagsPlugin.tags, (tag) => tag.facet);
      return [
        {
          sourceId: 'filters',
          getItems() {
            // Fetch facet values for _tags to populate the checkbox menu.
            // getAlgoliaFacets: https://www.algolia.com/doc/ui-libraries/autocomplete/api-reference/sources/#param-getalgoliafacets
            return getAlgoliaFacets({
              searchClient,
              queries: [
                {
                  indexName: '{{{env.ALGOLIA_INDEX_NAME}}}',
                  facet: '_tags',
                  params: {
                    facetQuery: '',     // https://www.algolia.com/doc/api-reference/api-parameters/facetQuery/
                    maxFacetHits: 50,   // https://www.algolia.com/doc/api-reference/api-parameters/maxFacetHits/
                  },
                },
              ],
              transformResponse({ facetHits }) {
                // We return raw server facets; union with known+selected happens in render().
                const server = (facetHits[0] || []).map(h => ({ label: h.label, facet: '_tags' }));
                return server;
              },
            });
          },
          templates: {
            header() { return null; },
            item() { return null; },
          },
        },

        {
          sourceId: 'docs',
          getItems() {
            // getAlgoliaResults: https://www.algolia.com/doc/ui-libraries/autocomplete/api-reference/sources/#param-getalgoliaresults
            return getAlgoliaResults({
              searchClient,
              queries: [
                {
                  indexName: '{{{env.ALGOLIA_INDEX_NAME}}}',
                  query,
                  params: {
                    clickAnalytics: true,           // https://www.algolia.com/doc/api-reference/api-parameters/clickAnalytics/
                    hitsPerPage: 10,                // https://www.algolia.com/doc/api-reference/api-parameters/hitsPerPage/
                    attributesToSnippet: ['*:25'],  // https://www.algolia.com/doc/api-reference/api-parameters/attributesToSnippet/
                    snippetEllipsisText: '…',       // https://www.algolia.com/doc/api-reference/api-parameters/snippetEllipsisText/
                    tagFilters: mapToAlgoliaFilters(tagsByFacet), // https://www.algolia.com/doc/api-reference/api-parameters/tagFilters/
                  },
                },
              ],
              transformResponse({ hits }) {
                // Re-order mixed hits so Docs stay in place while non-Doc items
                // are time-sorted, and compute a matchingHeading to deep-link
                // to the best title match.
                return hits.map((nestedHits) => {
                  const docIndices = new Map();
                  nestedHits.forEach((item, index) => {
                    if (item.type === 'Doc') {
                      docIndices.set(index, item);
                    }
                  });

                  const nonDocItems = nestedHits
                    .filter((item) => item.type !== 'Doc')
                    .sort((a, b) => (b.unixTimestamp ?? -Infinity) - (a.unixTimestamp ?? -Infinity));

                  let nonDocIndex = 0;

                  docIndices.forEach((item, index) => {
                    if (item._highlightResult && item._highlightResult.titles) {
                      const matchedIndex = item._highlightResult.titles.findIndex(
                        (title) => title.t.matchLevel === 'full'
                      );
                      if (matchedIndex !== -1) {
                        const matchedTopLevelTitle = item.titles[matchedIndex];
                        if (matchedTopLevelTitle) {
                          item.matchingHeading = `#${matchedTopLevelTitle.h}`;
                        }
                      }
                    }
                    nestedHits[index] = item;
                  });

                  return nestedHits.map((item, index) =>
                    docIndices.has(index) ? docIndices.get(index) : nonDocItems[nonDocIndex++]
                  );
                });
              },
            });
          },
          templates: {
            noResults({ state, html }) {
              // Clear preview so we don’t show stale content for a query with no hits.
              state.context.preview = null;
              if (!state.query) return;
              return html`
                <div>No results for ${state.query}</div>
                <p>
                  Believe this query should return results?
                  <a target="_blank" rel="noopener noreferrer" href="https://github.com/redpanda-data/documentation/issues/new?title=No%20search%20results%20for%20${state.query}">
                    Let us know
                  </a>.
                </p>`;
            },
            header({ items, html }) {
              if (!items.length) return;
              return html`
                <span class="aa-SourceHeaderTitle">Results</span>
                <div class="aa-SourceHeaderLine"></div>`;
            },
            item({ item, components, html }) {
              const matchingHeading = item.matchingHeading || '';

              // Helper: render “product” as deduped badges
              const renderProduct = (product) => {
                if (Array.isArray(product)) {
                  const seen = new Set();
                  return product
                    .filter(p => { const k = (p || '').toLowerCase(); if (seen.has(k)) return false; seen.add(k); return true; })
                    .map(p => html`<div class="aa-ItemContentTitle result-type">${p}</div>`);
                } else if (product) {
                  return html`<div class="aa-ItemContentTitle result-type">${product}</div>`;
                }
                return null;
              };

              // If previewable, navigate within the panel; otherwise open a new tab.
              const aTag = SUPPORTED_PREVIEW_TYPES.includes((item.type || '').toLowerCase())
                ? html`<a class="aa-ItemLink" href="${item.url || item.objectID}${matchingHeading}">
                    <div class="aa-ItemContent">
                      <div class="aa-ItemContentBody">
                        <div class="aa-ItemContentRow">
                          <div class="aa-ItemContentTitle">
                            ${components.Highlight({ hit: item, attribute: 'title' })}
                          </div>
                        </div>
                        ${
                          item.text
                            ? html`<div class="aa-ItemContentSnippet">${
                                item.text
                                  ? components.Snippet({ hit: item, attribute: 'text' })
                                  : item.intro
                                  ? components.Snippet({ hit: item, attribute: 'intro' })
                                  : item.description
                                  ? components.Snippet({ hit: item, attribute: 'description' })
                                  : ''
                              }</div>`
                            : html`<div class="aa-ItemContentSnippet">${
                                item.intro
                                  ? components.Snippet({ hit: item, attribute: 'intro' })
                                  : item.description
                                  ? components.Snippet({ hit: item, attribute: 'description' })
                                  : ''
                              }</div>`
                        }
                        <div class="aa-ItemContentRow">
                          <div class="aa-ItemContentTitle result-type">${item.type}</div>
                          ${renderProduct(item.product)}
                          ${item.api ? html`<div class="aa-ItemContentTitle result-type">${item.api}</div>` : ''}
                          ${item.version ? html`<div class="aa-ItemContentTitle result-type">${item.version}</div>` : ''}
                        </div>
                      </div>
                      <div class="aa-ItemActions">
                        <button class="aa-ItemActionButton aa-DesktopOnly aa-ActiveOnly" type="button" aria-label="Open page" title="Open page">
                          <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor"><path d="M18.984 6.984h2.016v6H5.812l3.609 3.609-1.406 1.406-6-6 6-6 1.406 1.406L5.812 7.97H18.984V3.94z" /></svg>
                        </button>
                      </div>
                    </div>
                  </a>`
                : html`<a target="_blank" rel="noopener noreferrer" class="aa-ItemLink" href="${item.url || item.objectID}">
                    <div class="aa-ItemContent">
                      <div class="aa-ItemContentBody">
                        <div class="aa-ItemContentRow">
                          <div class="aa-ItemContentTitle">
                            ${components.Highlight({ hit: item, attribute: 'title' })}
                          </div>
                        </div>
                        ${
                          item.breadcrumbs
                            ? html`<div class="aa-ItemContentRow">
                                <div class="aa-Breadcrumbs">
                                  <ul>
                                    ${
                                      item.breadcrumbs.length > 2 &&
                                      item.breadcrumbs
                                        .slice(1, item.breadcrumbs.length - 1)
                                        .map((breadcrumb) => html`<li>${breadcrumb.t}</li>`)
                                    }
                                    ${
                                      item.breadcrumbs.length === 2 &&
                                      item.breadcrumbs.slice(1).map((breadcrumb) => html`<li>${breadcrumb.t}</li>`)
                                    }
                                  </ul>
                                </div>
                              </div>`
                            : ''
                        }
                        <div class="aa-ItemContentSnippet">${
                          item.text
                            ? components.Snippet({ hit: item, attribute: 'text' })
                            : item.intro
                            ? components.Snippet({ hit: item, attribute: 'intro' })
                            : item.description
                            ? components.Snippet({ hit: item, attribute: 'description' })
                            : ''
                        }</div>
                        <div class="aa-ItemContentRow">
                          <div class="aa-ItemContentTitle result-type">${item.type}</div>
                          ${renderProduct(item.product)}
                          ${item.version ? html`<div class="aa-ItemContentTitle result-type">${item.version}</div>` : ''}
                        </div>
                      </div>
                      <div class="aa-ItemActions">
                        <button class="aa-ItemActionButton aa-DesktopOnly aa-ActiveOnly" type="button" aria-label="Open page" title="Open page">
                          <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor"><path d="M18.984 6.984h2.016v6H5.812l3.609 3.609-1.406 1.406-6-6 6-6 1.406 1.406L5.812 7.97H18.984V3.94z" /></svg>
                        </button>
                      </div>
                    </div>
                  </a>`;
              return html`${aTag}`;
            },
          },
          getItemUrl({ item }) { return item.url || item.objectID; },
          onActive({ item, setContext, state }) {
            const ctx = state?.context || {};
            setContext({ ...ctx, preview: item });
          },
        }
      ];
    },
  });

  /**
   * Expose the Autocomplete instance globally so other UI (our custom dropdown)
   * can drive its context without capturing stale references across re-renders.
   * This is intentionally namespaced and “private”. See notes below.
   */
  window.__algoliaAutocompleteInstance = autocompleteInstance;
});
</script>
